name: Deploy to VM via SSH (build on runner -> scp -> load + docker compose)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      ssh_user:
        description: 'SSH user on the VM (default: gcpuser)'
        required: false
        default: 'gcpuser'

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      IMAGE_NAME: oneit-blog
      IMAGE_TAG: ${{ github.sha }}
      REGISTRY_IMAGE: us-east1-docker.pkg.dev/blog-flask-oneit/blog-repo/flask-blog

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          # Build with both local tag and registry tag for pushing later (optional)
          docker build -t "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" .
          docker tag "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" "${{ env.REGISTRY_IMAGE }}:${{ env.IMAGE_TAG }}"
          docker tag "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" "${{ env.REGISTRY_IMAGE }}:latest"

      - name: Save image and compress
        run: |
          docker save "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" -o image.tar
          gzip -9 image.tar

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

      - name: Create remote deployment directory
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"
          ssh -i ~/.ssh/id_rsa ${SSH_USER}@${{ secrets.VM_IP }} "mkdir -p ${REMOTE_DIR}"

      - name: Copy image and compose file to VM
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"
          scp -i ~/.ssh/id_rsa image.tar.gz ${SSH_USER}@${{ secrets.VM_IP }}:${REMOTE_DIR}/
          scp -i ~/.ssh/id_rsa docker-compose.yml ${SSH_USER}@${{ secrets.VM_IP }}:${REMOTE_DIR}/ || true
          scp -i ~/.ssh/id_rsa .env.example ${SSH_USER}@${{ secrets.VM_IP }}:${REMOTE_DIR}/.env 2>/dev/null || true

      - name: Generate .env file on VM with database config
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"
          # Generate .env with safe defaults on the remote VM
          ssh -i ~/.ssh/id_rsa ${SSH_USER}@${{ secrets.VM_IP }} << EOF
          cat > ${REMOTE_DIR}/.env << 'ENVFILE'
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=postgres_secure_password
          POSTGRES_DB=blog_db
          ENVFILE
          chmod 600 ${REMOTE_DIR}/.env
          echo "âœ“ .env file created with database configuration"
          grep -v PASSWORD ${REMOTE_DIR}/.env || true
          EOF

      - name: "Remote: load image and run docker compose"
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          REGISTRY_IMAGE: ${{ env.REGISTRY_IMAGE }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"

          # Create a robust remote script that will: load image, patch compose (to use the local image tag), and run docker compose
          cat > /tmp/remote-deploy.sh <<'BASHEOF'
          #!/bin/bash
          set -euo pipefail

          REMOTE_DIR="$1"
          IMAGE_NAME="$2"
          IMAGE_TAG="$3"
          REGISTRY_IMAGE="$4"

          cd "$REMOTE_DIR"

          DOCKER_CMD="docker"
          if ! command -v ${DOCKER_CMD} >/dev/null 2>&1; then
            if command -v sudo >/dev/null 2>&1; then
              DOCKER_CMD="sudo docker"
            else
              echo "ERROR: docker not available on remote host" >&2
              exit 1
            fi
          fi

          if [ -f image.tar.gz ]; then
            echo "Loading image from image.tar.gz..."
            gunzip -c image.tar.gz > image.tar
            ${DOCKER_CMD} load -i image.tar
            rm -f image.tar image.tar.gz
            echo "Image loaded successfully as ${IMAGE_NAME}:${IMAGE_TAG}"
          else
            echo "ERROR: image.tar.gz not found in ${REMOTE_DIR}" >&2
            exit 1
          fi

          echo "Tagging loaded image as ${REGISTRY_IMAGE}:${IMAGE_TAG}..."
          ${DOCKER_CMD} tag "${IMAGE_NAME}:${IMAGE_TAG}" "${REGISTRY_IMAGE}:${IMAGE_TAG}" || true
          ${DOCKER_CMD} tag "${IMAGE_NAME}:${IMAGE_TAG}" "${REGISTRY_IMAGE}:latest" || true

          if [ -f docker-compose.yml ]; then
            echo "Updating docker-compose.yml to use IMAGE_TAG=${IMAGE_TAG}..."
            sed -i "s|image: .*flask-blog:.*|image: ${REGISTRY_IMAGE}:${IMAGE_TAG}|g" docker-compose.yml

            echo "Stopping and removing old containers..."
            if ${DOCKER_CMD} compose -f docker-compose.yml ps >/dev/null 2>&1; then
              ${DOCKER_CMD} compose -f docker-compose.yml down --remove-orphans 2>/dev/null || true
            fi

            echo "Force-freeing port 80..."
            if command -v sudo >/dev/null 2>&1; then
              sudo lsof -ti:80 2>/dev/null | xargs -r sudo kill -9 2>/dev/null || true
              sudo fuser -k 80/tcp 2>/dev/null || true
            else
              fuser -k 80/tcp 2>/dev/null || lsof -ti:80 | xargs -r kill -9 2>/dev/null || true
            fi
            sleep 2
            ${DOCKER_CMD} rm -f blog_db flask_blog 2>/dev/null || true

            if [ ! -f "${REMOTE_DIR}/.env" ]; then
              echo "Creating .env with defaults..."
              printf "POSTGRES_USER=postgres\nPOSTGRES_PASSWORD=postgres_secure_password\nPOSTGRES_DB=blog_db\n" > "${REMOTE_DIR}/.env"
              chmod 600 "${REMOTE_DIR}/.env"
            fi

            echo "Starting containers with docker compose (no pull, use local images)..."
            # Ensure the registry-tagged image exists locally; if not, warn and list images
            if ! ${DOCKER_CMD} image inspect "${REGISTRY_IMAGE}:${IMAGE_TAG}" >/dev/null 2>&1; then
              echo "WARNING: expected image ${REGISTRY_IMAGE}:${IMAGE_TAG} not found locally. Listing images for debugging:" >&2
              ${DOCKER_CMD} images | head -n 50 || true
            fi

            # Try to run compose without pulling from remote registry. Use --pull never if supported.
            if ${DOCKER_CMD} compose version >/dev/null 2>&1; then
              echo "Using 'docker compose' and attempting to avoid remote pulls"
              # Try with --no-build --pull never (newer compose)
              if ${DOCKER_CMD} compose --no-build --pull never --env-file "${REMOTE_DIR}/.env" -f docker-compose.yml up -d --remove-orphans >/dev/null 2>&1; then
                echo "Containers started with --pull never"
              else
                echo "Fallback: try with --no-build (without explicit pull policy)"
                ${DOCKER_CMD} compose --no-build --env-file "${REMOTE_DIR}/.env" -f docker-compose.yml up -d --remove-orphans || true
              fi
              sleep 3
              ${DOCKER_CMD} compose -f docker-compose.yml logs --tail=20 || true
            else
              if command -v docker-compose >/dev/null 2>&1; then
                echo "Legacy docker-compose detected: using --no-build to avoid pulls"
                docker-compose --no-build --env-file "${REMOTE_DIR}/.env" -f docker-compose.yml up -d --remove-orphans || true
                sleep 3
                docker-compose -f docker-compose.yml logs --tail=20 || true
              else
                echo "ERROR: neither docker compose nor docker-compose available" >&2
                exit 1
              fi
            fi

            echo "Container status:"
            ${DOCKER_CMD} compose -f docker-compose.yml ps || true
          else
            echo "WARNING: docker-compose.yml not found"
          fi

          echo "Remote deploy finished"
          BASHEOF

          chmod +x /tmp/remote-deploy.sh

          ssh -i ~/.ssh/id_rsa ${SSH_USER}@${{ secrets.VM_IP }} "bash -s" < /tmp/remote-deploy.sh ${REMOTE_DIR} ${IMAGE_NAME} ${IMAGE_TAG} ${REGISTRY_IMAGE}

      - name: Cleanup local artifacts
        run: |
          rm -f image.tar.gz image.tar || true

      - name: Notes
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          echo "Deployed image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} to ${SSH_USER}@${{ secrets.VM_IP }}"
          echo "If the remote user is different than the default 'gcpuser', re-run the workflow and set the 'ssh_user' input."
