name: Deploy to VM via SSH (build on runner -> scp -> load + docker compose)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      ssh_user:
        description: 'SSH user on the VM (default: gcpuser)'
        required: false
        default: 'gcpuser'

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      IMAGE_NAME: oneit-blog
      IMAGE_TAG: ${{ github.sha }}
      REGISTRY_IMAGE: us-east1-docker.pkg.dev/blog-flask-oneit/blog-repo/flask-blog

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          # Build with both local tag and registry tag for pushing later (optional)
          docker build -t "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" .
          docker tag "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" "${{ env.REGISTRY_IMAGE }}:${{ env.IMAGE_TAG }}"
          docker tag "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" "${{ env.REGISTRY_IMAGE }}:latest"

      - name: Save image and compress
        run: |
          docker save "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" -o image.tar
          gzip -9 image.tar

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

      - name: Create remote deployment directory
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"
          ssh -i ~/.ssh/id_rsa ${SSH_USER}@${{ secrets.VM_IP }} "mkdir -p ${REMOTE_DIR}"

      - name: Copy image and compose file to VM
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"
          scp -i ~/.ssh/id_rsa image.tar.gz ${SSH_USER}@${{ secrets.VM_IP }}:${REMOTE_DIR}/
          scp -i ~/.ssh/id_rsa docker-compose.yml ${SSH_USER}@${{ secrets.VM_IP }}:${REMOTE_DIR}/ || true
          scp -i ~/.ssh/id_rsa .env.example ${SSH_USER}@${{ secrets.VM_IP }}:${REMOTE_DIR}/.env 2>/dev/null || true

      - name: Generate .env file on VM with database config
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"
          # Generate .env with safe defaults on the remote VM
          ssh -i ~/.ssh/id_rsa ${SSH_USER}@${{ secrets.VM_IP }} << EOF
          cat > ${REMOTE_DIR}/.env << 'ENVFILE'
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=postgres_secure_password
          POSTGRES_DB=blog_db
          ENVFILE
          chmod 600 ${REMOTE_DIR}/.env
          echo "✓ .env file created with database configuration"
          grep -v PASSWORD ${REMOTE_DIR}/.env || true
          EOF

      - name: "Remote: load image and run docker compose"
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          REGISTRY_IMAGE: ${{ env.REGISTRY_IMAGE }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"

          # Create a robust remote script that will: load image, patch compose (to use the local image tag), and run docker compose
          cat > /tmp/remote-deploy.sh <<'EOF'
          #!/bin/bash
          set -euo pipefail

          REMOTE_DIR="$1"
          IMAGE_NAME="$2"
          IMAGE_TAG="$3"
          REGISTRY_IMAGE="$4"

          cd "$REMOTE_DIR"

          # Determine docker command (try docker, fallback to sudo docker)
          DOCKER_CMD="docker"
          if ! command -v ${DOCKER_CMD} >/dev/null 2>&1; then
            if command -v sudo >/dev/null 2>&1; then
              DOCKER_CMD="sudo docker"
            else
              echo "ERROR: docker not available on remote host" >&2
              exit 1
            fi
          fi

          # Decompress and load image
          if [ -f image.tar.gz ]; then
            echo "Loading image from image.tar.gz..."
            gunzip -c image.tar.gz > image.tar
            ${DOCKER_CMD} load -i image.tar
            rm -f image.tar image.tar.gz
            echo "Image loaded successfully as ${IMAGE_NAME}:${IMAGE_TAG}"
          else
            echo "ERROR: image.tar.gz not found in ${REMOTE_DIR}" >&2
            exit 1
          fi

          # Tag the loaded image with the registry name so docker compose can find it
          echo "Tagging loaded image as ${REGISTRY_IMAGE}:${IMAGE_TAG}..."
          ${DOCKER_CMD} tag "${IMAGE_NAME}:${IMAGE_TAG}" "${REGISTRY_IMAGE}:${IMAGE_TAG}" || true
          ${DOCKER_CMD} tag "${IMAGE_NAME}:${IMAGE_TAG}" "${REGISTRY_IMAGE}:latest" || true

          # If a docker-compose.yml exists, ensure the image reference is set correctly
          if [ -f docker-compose.yml ]; then
            echo "Updating docker-compose.yml to use IMAGE_TAG=${IMAGE_TAG}..."
            # Replace the image line to use the registry image with the specific tag
            sed -i "s|image: .*flask-blog:.*|image: ${REGISTRY_IMAGE}:${IMAGE_TAG}|g" docker-compose.yml

            # Stop and remove old containers to avoid port conflicts
            echo "Stopping and removing old containers..."
            if ${DOCKER_CMD} compose -f docker-compose.yml ps >/dev/null 2>&1; then
              ${DOCKER_CMD} compose -f docker-compose.yml down --remove-orphans 2>/dev/null || true
            fi

            # Force-kill any process using port 80 (aggressive cleanup)
            echo "Force-freeing port 80..."
            if command -v sudo >/dev/null 2>&1; then
              sudo lsof -ti:80 2>/dev/null | xargs -r sudo kill -9 2>/dev/null || true
              sudo fuser -k 80/tcp 2>/dev/null || true
            else
              fuser -k 80/tcp 2>/dev/null || lsof -ti:80 | xargs -r kill -9 2>/dev/null || true
            fi

            # Give the OS a moment to release the port
            sleep 2

            # Force-remove leftover containers by name (avoid name conflicts)
            echo "Removing leftover containers by name (if any)..."
            ${DOCKER_CMD} rm -f blog_db flask_blog 2>/dev/null || true

            echo "Starting containers with docker compose..."
            # Verify .env exists and is readable
            if [ ! -f "${REMOTE_DIR}/.env" ]; then
              echo "WARNING: .env not found in ${REMOTE_DIR}, attempting to create with defaults..."
              cat > "${REMOTE_DIR}/.env" << 'ENVDEFAULT'
              POSTGRES_USER=postgres
              POSTGRES_PASSWORD=postgres_secure_password
              POSTGRES_DB=blog_db
              ENVDEFAULT
              chmod 600 "${REMOTE_DIR}/.env"
            fi

            # Try modern `docker compose` first then fall back to legacy `docker-compose`
            if ${DOCKER_CMD} compose version >/dev/null 2>&1; then
              echo "Using 'docker compose' with env file: ${REMOTE_DIR}/.env"
              ${DOCKER_CMD} compose --env-file "${REMOTE_DIR}/.env" -f docker-compose.yml up -d --remove-orphans || true
              sleep 3
              # Check if services started; if not, show logs
              if ! ${DOCKER_CMD} compose -f docker-compose.yml ps | grep -q "Up"; then
                echo "WARNING: Containers may not have started. Checking logs..."
                ${DOCKER_CMD} compose -f docker-compose.yml logs --tail=20 || true
              fi
            else
              if command -v docker-compose >/dev/null 2>&1; then
                echo "Using legacy 'docker-compose' with env file: ${REMOTE_DIR}/.env"
                docker-compose --env-file "${REMOTE_DIR}/.env" -f docker-compose.yml up -d --remove-orphans || true
                sleep 3
                if ! docker-compose -f docker-compose.yml ps | grep -q "Up"; then
                  echo "WARNING: Containers may not have started. Checking logs..."
                  docker-compose -f docker-compose.yml logs --tail=20 || true
                fi
              else
                echo "ERROR: neither 'docker compose' nor 'docker-compose' available on remote host" >&2
                exit 1
              fi
            fi

            echo "✓ Containers started successfully"
          else
            echo "WARNING: docker-compose.yml not found; nothing to start. Image loaded as ${IMAGE_NAME}:${IMAGE_TAG}"
          fi

          # Verify containers are running
          echo ""
          echo "=== Current running containers ==="
          ${DOCKER_CMD} compose -f docker-compose.yml ps 2>/dev/null || ${DOCKER_CMD} ps --filter "label=com.docker.compose.project" 2>/dev/null || true
          echo "Remote deploy finished"
          EOF

          chmod +x /tmp/remote-deploy.sh

          ssh -i ~/.ssh/id_rsa ${SSH_USER}@${{ secrets.VM_IP }} "bash -s" < /tmp/remote-deploy.sh ${REMOTE_DIR} ${IMAGE_NAME} ${IMAGE_TAG} ${REGISTRY_IMAGE}

      - name: Cleanup local artifacts
        run: |
          rm -f image.tar.gz image.tar || true

      - name: Notes
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          echo "Deployed image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} to ${SSH_USER}@${{ secrets.VM_IP }}"
          echo "If the remote user is different than the default 'gcpuser', re-run the workflow and set the 'ssh_user' input."
