name: Deploy to VM via SSH (build on runner -> scp -> load + docker compose)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      ssh_user:
        description: 'SSH user on the VM (default: gcpuser)'
        required: false
        default: 'gcpuser'

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      IMAGE_NAME: oneit-blog
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          docker build -t "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" .

      - name: Save image and compress
        run: |
          docker save "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" -o image.tar
          gzip -9 image.tar

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

      - name: Create remote deployment directory
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"
          ssh -i ~/.ssh/id_rsa ${SSH_USER}@${{ secrets.VM_IP }} "mkdir -p ${REMOTE_DIR}"

      - name: Copy image and compose file to VM
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"
          scp -i ~/.ssh/id_rsa image.tar.gz ${SSH_USER}@${{ secrets.VM_IP }}:${REMOTE_DIR}/
          scp -i ~/.ssh/id_rsa docker-compose.yml ${SSH_USER}@${{ secrets.VM_IP }}:${REMOTE_DIR}/ || true

      - name: "Remote: load image and run docker compose"
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          REMOTE_DIR="/tmp/deploy-${{ github.run_id }}"

          # Create a robust remote script that will: load image, patch compose (to use the local image tag), and run docker compose
          cat > /tmp/remote-deploy.sh <<'EOF'
          #!/bin/bash
          set -euo pipefail

          REMOTE_DIR="$1"
          IMAGE_NAME="$2"
          IMAGE_TAG="$3"

          cd "$REMOTE_DIR"

          # Determine docker command (try docker, fallback to sudo docker)
          DOCKER_CMD="docker"
          if ! command -v ${DOCKER_CMD} >/dev/null 2>&1; then
            if command -v sudo >/dev/null 2>&1; then
              DOCKER_CMD="sudo docker"
            else
              echo "ERROR: docker not available on remote host" >&2
              exit 1
            fi
          fi

          # Decompress and load image
          if [ -f image.tar.gz ]; then
            echo "Loading image from image.tar.gz..."
            gunzip -c image.tar.gz > image.tar
            ${DOCKER_CMD} load -i image.tar
            rm -f image.tar image.tar.gz
          else
            echo "ERROR: image.tar.gz not found in ${REMOTE_DIR}" >&2
            exit 1
          fi

          # If a docker-compose.yml exists, update the image reference to the loaded local tag (best-effort)
          if [ -f docker-compose.yml ]; then
            # Replace any 'image: <something>' line for the service named 'app' or first occurrence; this is intentionally conservative.
            # We change the first 'image:' occurrence to point to our loaded image name:tag
            sed -i '0,/image:/s|image:.*|image: '"${IMAGE_NAME}:${IMAGE_TAG}"'|' docker-compose.yml || true

            echo "Starting containers with docker compose..."
            # Try modern `docker compose` first then fall back to legacy `docker-compose`
            if ${DOCKER_CMD} compose version >/dev/null 2>&1; then
              ${DOCKER_CMD} compose -f docker-compose.yml up -d --remove-orphans
            else
              if command -v docker-compose >/dev/null 2>&1; then
                docker-compose -f docker-compose.yml up -d --remove-orphans
              else
                echo "ERROR: neither 'docker compose' nor 'docker-compose' available on remote host" >&2
                exit 1
              fi
            fi
          else
            echo "WARNING: docker-compose.yml not found; nothing to start. Image loaded as ${IMAGE_NAME}:${IMAGE_TAG}"
          fi

          echo "Remote deploy finished"
          EOF

          chmod +x /tmp/remote-deploy.sh

          ssh -i ~/.ssh/id_rsa ${SSH_USER}@${{ secrets.VM_IP }} "bash -s" < /tmp/remote-deploy.sh ${REMOTE_DIR} ${IMAGE_NAME} ${IMAGE_TAG}

      - name: Cleanup local artifacts
        run: |
          rm -f image.tar.gz image.tar || true

      - name: Notes
        env:
          SSH_USER: ${{ github.event.inputs.ssh_user || 'gcpuser' }}
        run: |
          echo "Deployed image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} to ${SSH_USER}@${{ secrets.VM_IP }}"
          echo "If the remote user is different than the default 'gcpuser', re-run the workflow and set the 'ssh_user' input."
